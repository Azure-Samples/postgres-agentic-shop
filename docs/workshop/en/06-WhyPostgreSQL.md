# Detailed Vector, Rerank, and Graph Queries on PostgreSQL

This section describes the actual table configuration of PostgreSQL used in the AgenticShop solution and provides concrete examples of vector search, rerank, and graph data queries. Let's understand how we are using advanced queries made possible by integrating extensions into PostgreSQL.

## Table List and Schema

The data handled in AgenticShop mainly relates to "products" and "reviews". The repository's dataset (Agentic Shop dataset) includes products and corresponding user reviews for three categories: headphones, smartwatches, and tablets. Corresponding to each, the following tables exist on PostgreSQL.

**product table (product information)**: This table stores basic product information. The main columns are as follows:
- id: Product ID (integer, primary key)
- name: Product name (text)
- category: Product category (text, e.g., "headphones", "smartwatches", "tablets")
- price: Price (integer)
- brand: Brand name (variable-length text)
- description: Product description (text, detailed free description)
- specifications: JSON data summarizing the product's features (jsonb type). Features extracted from the description using LLM (e.g., design, battery performance, water resistance, etc.) are stored in key-value pairs. Used in the graph analysis described later.

**data_embeddings_products table (product embedding information)**: This table stores the embeddings of product descriptions.
- embedding: Embedding vector of product description (vector type). A vector of about 1536 dimensions generated by Azure OpenAI's Embedding model is stored.

In addition, an index is created on the `embedding` column to optimize vector search (`pgvector` supports indexes for Inner Product and Cosine distance).

**reviews table (review information)**: This table stores user product reviews. The main columns are as follows:
- id: Review ID (integer, primary key)
- product_id: Product ID of the review target (integer, references products.id as a foreign key)
- review_text: Review text (text, free-form content written by the user)

**data_embeddings_reviews table (review embedding information)**: This table stores the embeddings of user product reviews. The main columns are as follows:
- embedding: Embedding vector of review text (vector type).
A vector index is also created on this column. This speeds up the process of semantically searching review content.

The above two tables are the core data. As a relation, `reviews.product_id` is a foreign key to `products.id`, linking products and reviews (multiple reviews correspond to one product).

Furthermore, in AgenticShop, products, reviews, and features are graphed using Apache AGE. The following concepts are treated as nodes and edges when graphing.
**Nodes**:
- Product nodes: One node per product. Holds attributes such as product ID, name, category, feature JSON, etc.
- Review nodes: One node per review. Holds attributes such as review ID, text, feature JSON, etc.
- Feature nodes: One node per feature word extracted from products and reviews (e.g., "battery life", "soundQuality", "waterResistance", "design", etc.). Has a `name` attribute (feature name).

**Edges**:
- (:Product)-[:REVIEWS]->(:Review): Edge from the product node to its review node.
- (:Product)-[:HAS_FEATURE]->(:Feature): Edge from the product node to the feature node included in its product description. For example, if the product description talks about "water resistance", there is an edge connecting that product and the feature "waterResistance".

These graph data are managed within `ag_catalog` by PostgreSQL's `AGE` extension. The process of extracting features from the `products` and `reviews` tables and creating graph nodes and edges is executed in deployment scripts and backend initialization code (for example, creating feature nodes for all products and creating `HAS_FEATURE` edges, creating `REVIEWS` edges for all reviews, etc.).

## Queries for Vector, Rerank, and Graph Data

In AgenticShop, we are executing advanced queries using the above data and extensions. Here, we will give examples of representative queries and explain their content.

**Vector Similarity Search Query (Semantic Similarity Search)**:

To find products and reviews that match the user's questions or interests, we perform similarity searches using embedding vectors. For example, in response to the question "Which headphones have clear call quality and a good reputation for battery life?", the system first searches for the top 10 similar products from product descriptions, and then finds the top 10 similar reviews from the reviews associated with those products, performing a two-stage search. The SQL example would be as follows (simplified):

```sql
WITH potential_products AS (
  SELECT id, name, description
  FROM products
  WHERE category = 'headphones'
  ORDER BY description_emb <=> azure_openai.create_embeddings('text-embedding-ada-002', 'good clear calling')::vector
  ASC
  LIMIT 10
)
SELECT p.id AS product_id, r.id AS review_id, p.name, p.description, r.review_text
FROM potential_products p
LEFT JOIN reviews r USING (product_id)
ORDER BY r.review_text_emb <=> azure_openai.create_embeddings('text-embedding-ada-002', 'good battery life')::vector
ASC
LIMIT 10;
```

Here, we first sort the products in the `products` table with the category `headphones` that have a description close to the phrase "good clear calling" by vector distance `<=>`. `azure_openai.create_embeddings('text-embedding-ada-002', '...')` is a function that vectorizes the query sentence via Azure OpenAI (provided by the `azure_ai` extension). The top 10 products from this result are taken as `potential_products`, and then their reviews are joined from the `reviews` table, and this time we sort by those with review text close to "good battery life" by vector distance. Finally, we can obtain reviews and their products with high relevance. A major feature is that embedding generation and vector comparison are performed directly within SQL.

**Document Reranking Query**:
Reranking is the process of reordering the results obtained from vector search based on an LLM evaluation. The `azure_ai.rank()` function of the Azure AI extension calculates relevance scores for the given query and document set using LLM (or a cross-encoder model) and returns the ranking in order of the most matching ones. For example, the query to evaluate "which review emphasizes the clarity of the call" against the previous set of reviews would be as follows.

```sql
WITH reviews(id, text) AS (
  VALUES
    (1, 'The product has a great battery life.'),
    (2, 'Noise cancellation does not work as advertised. Avoid this product.'),
    (3, 'Good design, but a bit heavy. Not recommended for travel.'),
In the above example, four review sentences are input and ranked based on their relevance to the query "Can it make clear calls that block out background noise?". The results are returned with the `rank` value being smaller the higher the relevance (with 1st place output as `rank=1`), and review ID2 "Noise canceling does not work as expected" is evaluated as the most relevant (= mentioned issues with call quality). This is because LLM ranks the text based on its overall meaning, allowing for subtle context adjustments that cannot be captured by vector distance alone. At AgenticShop, we use this reranking to optimize the display order of search results and to extract reviews that best answer user questions.

**Graph Query (Querying with openCypher)**:
The advantage of graphing products, reviews, and features is that it allows for narrowing down complex conditions based on relationships. With Cypher queries, you can use pattern matching to, for example, find "products in the headphone category that have a feature related to design, also have a feature of water resistance, and have positive mentions about sound quality in their group of reviews". This condition is very complex, but in Cypher it can be described as follows:

```sql
MATCH (p:product {category: 'headphones'})
  -[:HAS_FEATURE]->(:feature {name: 'design'})
  WITH p
MATCH (p)-[:HAS_FEATURE]->(:feature {name: 'waterResistance'})
  WITH p
MATCH (p)-[:HAS_REVIEW]->(r:review)
  -[:MENTIONS_FEATURE {sentiment: 'positive'}]->(:feature {name: 'soundQuality'})
RETURN p.id, r.id;
```

This is called and executed from SQL as `cypher('products_reviews_features_graph', $$ <above query> $$)`. As a result, you can get a set of product IDs and review IDs that meet the criteria. At AgenticShop, we perform further post-processing on the SQL side based on these results. For example, we extract detailed information about the products and reviews obtained above from regular tables (`products`, `reviews`), have LLM determine whether the product description is "lightweight" and exclude non-compliant products (using the `azure_ai.is_true` function), and finally count the number of reviews per product while generating a summary sentence with LLM (using the `azure_ai.generate` function). The final query in this series is quite long, but it aggregates the results in one query by combining SQL, Cypher, and AI functions. This query allows you to get the top three "lightweight, waterproof headphones with high sound quality review ratings" with a summary.

In the actual result example, the product ID and name, each product feature summary (design, waterproof summary) and review summary, and the number of reviews are output. By having LLM summarize, users can be succinctly informed of features such as "These headphones are lightweight and waterproof. The sound quality was highly rated in the reviews."

In summary, we have looked at advanced queries used in AgenticShop.

In summary, vector search is powerful for narrowing down related items, reranking improves result accuracy through LLM's understanding, and graph queries extract relationships by combining multiple conditions. Because they can all be used consistently within PostgreSQL, there is no cost of data movement and complex questions can be answered.

In the hands-on, we recommend trying out queries like the above by actually connecting to PostgreSQL. Connect to the database with `psql` or `pgAdmin`, peek at the data with `SELECT * FROM products LIMIT 5;`, and try running a simple Cypher query. For example, a query to count the number of all product nodes and review nodes:

```sql
SELECT *
FROM cypher('products_reviews_features_graph', $$
  MATCH (p:product) RETURN count(p)
$$) AS t(count bigint);
```

By trying this, you can confirm that data is entered in the graph.

[Previous](05-Post-provisioning.md) | [Next](07-GraphRAG.md)
