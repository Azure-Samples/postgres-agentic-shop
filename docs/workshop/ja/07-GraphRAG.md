# GraphRAG Integration

## グラフRAGの知識グラフ構築（Graph Extraction）

AgenticShopのバックエンドではGraphRAGの一環として、製品レビューから知識グラフを構築しています。具体的には、PostgreSQLにApache AGE拡張を導入し、製品とその特徴（機能）をノードとして、レビュー内の言及関係をエッジとして表現したグラフを構築します。この処理はcreate_apache_age_graph.pyで実行されており、PostgreSQL上でAGEのcreate_graph関数を用いてグラフを生成しています（リテール用のグラフスキーマを作成）。また、generate_sentiments_for_reviews.pyで各レビュー中の特定の特徴に対するポジティブ/ネガティブな言及を分析し、これをグラフのエッジ情報として活用できる形でデータベースに格納しています。すなわち、製品ノードと特徴ノードを繋ぐエッジに、レビューでその特徴が言及された回数や感情（肯定/否定）の属性を持たせ、製品と特徴の関連知識グラフをデータベース内に構築しています。このグラフ抽出工程により、非構造なテキストから製品間の関係（共通の特徴やレビュー評価）を構造化データとして抽出しています。これによってバックエンドはPostgreSQLをリレーショナルDBとグラフDBの両方として利用し、複雑な関係クエリを可能にしています。

## Apache AGEによるグラフ統合とCypherクエリ

Apache AGE拡張を介して、バックエンドはPostgreSQL上でCypherクエリ（OpenCypher言語）を実行できるようになっています。Alembicマイグレーション内でCREATE EXTENSION ageおよびSELECT * FROM create_graph('graph_name')を実行し、グラフスキーマをPostgreSQL内に作成します。また、製品・特徴ノードやエッジ挿入もSQLから実行されます。たとえば、特徴リスト（features.csv）やレビューの分析結果から、各製品に対して「特徴Xがポジティブに言及された」ことを表すエッジをMATCH ... CREATE文で挿入しています。Apache AGEではCypherクエリをSQLのFROM句で呼び出すハイブリッドクエリが可能であり、本プロジェクトでもこれを活用しています。実際、PostgreSQLとAGEの統合により、従来のSQLフィルタとグラフクエリを組み合わせた問合せを発行できます。例えば、「特定製品群の中から、ある特徴について肯定的な言及数が多い製品を探す」ような処理を、一度のSQL+Cypherハイブリッドクエリで実行できます。Apache AGE統合のメリットは、LLM用の知識グラフを別のグラフDBに置く必要がなく、PostgreSQL内でリレーショナルデータとグラフデータを一貫して操作できる点です。

具体的なCypherクエリ発行箇所としては、バックエンドのサービス層でCypher関数付きSQLを実行しています。たとえば、特徴と感情に基づく製品フィルタリングでは、内部で以下のようなクエリを組み立てています（擬似コード）:

```sql
SELECT p.id, g.count
FROM products p
JOIN LATERAL cypher('retail_graph', $$
  MATCH (p:Product)-[m:MENTION {sentiment: "positive"}]->(f:Feature {name: "<特徴名>"})
  RETURN COUNT(m) as count
$$) AS g(count)
ON g.count > 0
WHERE p.category = '<カテゴリ>'
ORDER BY g.count DESC;
```

上記のように、PostgreSQLのSQL文にcypher('graph_name', $$ ... $$)を組み込み、グラフ内のエッジ数などを算出して結果をリレーショナルクエリに組み入れています。このようなOpenCypherクエリとSQLの混合により、通常のフィルタ（例: カテゴリ）とグラフ構造上の指標（例: 言及数）を同時に考慮した検索が可能になっています。

## 実行時におけるグラフRAGの活用（Graph Query Generation）

エンドユーザから質問や要求があった際、バックエンドではグラフクエリ生成を行い、知識グラフを用いた情報検索を実施します。GraphRAGのアルゴリズム上、これは「グラフクエリを生成し、LLMへの文脈情報として使用する」ステップに該当します。AgenticShopではユーザのクエリ内容やプロファイルに応じて、適切なグラフ問合せを発行しています。例えばユーザが「バッテリー寿命に関する評価が高いスマートフォンは？」と質問した場合、バックエンドのUserQueryAgentが以下のような処理を行います。
1. ベクトル検索で該当カテゴリーの製品候補を取得します（pgvectorを用いた類似度検索）。
2. グラフクエリ生成: 候補製品群に対し、「指定の特徴に対するポジティブレビュー数」を計算するCypher問合せを組み立てます。コード上はfetch_product_with_feature_and_sentiment_countという関数で実装されており、引数に製品IDリスト・感情種別・特徴名を受け取ってグラフクエリを実行します。この関数内で前述のようなCypher+SQLを発行し、各製品についてその特徴のポジティブ言及数を取得します。
3. 結果のランキング: 返ってきた各製品の言及数に基づき、製品リストを並べ替えます（言及数が多い=その特徴で評価の高い製品として順位を上げる）。GraphRAGではグラフ上の**“プロミネンス”**（重要度）のシグナルを活用して検索精度を上げるのが狙いであり、本ケースでは「ポジティブレビューの多さ」がプロミネンス指標になっています。
4. LLMへのコンテキスト提供: 最終的に上位N件の製品を選び、それぞれに対して関連するレビュー内容を要約したテキストを生成します（後述のエージェントワークフロー参照）。このとき、GraphRAGにより選ばれた重要度の高い製品やレビューが文脈としてLLMに与えられるため、ユーザの質問意図に沿った正確な回答が得られやすくなります。

コード上では、UserQueryAgent.query_reviews_with_sentimentメソッド内で上記ロジックが確認できます。以下はその一部抜粋で、特徴が指定された場合にグラフクエリ関数を呼び出している箇所です。

```python
if feature:
    product_ids_for_query = [product.id for product in results]
    product_ids_with_count = await self.fetch_product_with_feature_and_sentiment_count(
        product_ids_for_query, sentiment, feature[0]
    )
    # （返り値のproduct_ids_with_countを用いて製品リストをフィルタ/ソート）
```

ここでfeature[0]は特徴名（例：「バッテリー」）を示し、product_ids_for_queryは対象となる製品IDのリストです。この関数呼び出しにより、グラフデータベース上で該当製品群における指定特徴の言及数を集計し、結果がproduct_ids_with_countに格納されます。その後の処理で、この情報を使ってresults中の製品オブジェクトを並べ替え、回答用の上位製品を決定しています。

## マルチエージェントワークフローにおけるグラフ活用

AgenticShopはLlamaIndexベースのマルチエージェントフローを採用しており、検索結果の後処理や要約生成にもGraphRAGの成果を活かしています。バックエンドのmulti_agent_workflow.pyでは、run_workflows_in_backgroundという関数でバックグラウンドタスクとしてエージェントによる追加処理を起動します。このワークフローでは、ユーザごとのプロフィール情報や、グラフクエリで得られた知識を元に、各製品の詳細な説明やレビュー要約をLLMに生成させます。具体的には:
- パーソナライズド要約: ユーザの嗜好（プロフィールで好む特徴や重視点）に合わせ、各製品のレビューから relevant なポイントを抽出・要約します。GraphRAGで構築した製品-特徴グラフは、どの製品がユーザの関心特徴について高評価かを示す指針となります。エージェントはこの指針を使い、該当するレビューをベクトル検索（vector_store_reviews_embeddings）やグラフから探し出し、LLMに渡します。例えば「バッテリー寿命重視」のユーザには、その特徴に関するポジティブレビューが多い製品をグラフ経由で特定し、そのレビュー内容を重点的に要約するという流れです。
- プロンプト内での指示: backend/src/agents/prompts.pyを見ると、エージェントへの指示として「ユーザの嗜好に最も関連するレビューからインサイトを要約せよ」といった内容が含まれています。さらに「ユーザ嗜好そのものを要約結果にせず、あくまで製品に言及せよ」「製品カテゴリと無関係な嗜好は無視せよ」等、出力品質を高めるための細かなガイドラインも記載されています。これらはGraphRAGから得たグラフ構造を前提に、LLMが適切に情報を取捨選択できるよう設計されたプロンプトです。例えばグラフ上で無関係と判定される特徴（スマートウォッチに音質は無関係等）は要約に含めない指示となっています。

以上のように、グラフ構造は情報検索と要約の両面で活用されています。検索段階ではグラフから得たスコア（例: 特徴の言及数）で候補をランキングし、要約段階ではグラフが示す関連性に沿って適切なレビュー内容を抽出しています。

## GraphRAGのアーキテクチャ上の役割と利点

AgenticShopにおけるGraphRAGは、バックエンドの情報検索パイプラインを高度化する中核技術として機能しています。その役割とメリットは以下の通りです。
-	精度向上とランキング強化: 単純なベクトル検索ではテキスト類似度のみの評価となりますが、GraphRAGにより知識グラフ上の関係性を考慮できます。例えば「レビュー件数が多い」「ある特徴で高評価されている」といった情報はグラフから得られる重要なシグナルです。Legal Copilotの例では判例の被引用数をプロミネンス指標として精度向上しましたが、AgenticShopでは特徴に対する肯定的レビュー数を類似指標としてランキングに反映しています。これにより、ユーザの質問に対しより適切な（ユーザの求める観点で優れた）製品が上位に来るようになります。実際、GraphRAG導入により情報検索パイプラインの精度（リコール向上など）が飛躍的に改善することが報告されています。
-	リレーショナルデータとグラフデータの融合: GraphRAGはPostgreSQL内で動作するため、ユーザプロフィールや製品マスタなどリレーショナル情報と、レビュー由来のグラフ情報を一本化して扱えます。これによりシステム構成がシンプルになり、外部グラフDBとの同期を取る必要がありません。AgenticShopのアーキテクチャ上も、Azure Database for PostgreSQL一つでベクトル検索（pgvector）、全文検索、そしてグラフ検索を担っており、データ一貫性と管理容易性の面で大きな利点があります。
-	LLM応答質の向上: GraphRAGが提供する文脈（知識グラフに基づくコンテキスト）は、LLMの回答内容をより信頼性の高いものにします。例えばユーザが関心を持つ製品特徴について、グラフから得た「裏付けのある情報（レビュー評価や頻出するメリット）」を提示できるため、LLMは具体的で妥当性の高い回答を生成できます。これはRAGの目的である幻覚の抑制と正確性向上に直結します。AgenticShopではエージェントが複数の知識ソース（ベクトルDB・グラフDB）を横断して情報収集することで、よりユーザ意図にマッチした有用な回答（製品推薦や説明）を実現しています。

総括すると、AgenticShopバックエンドのbackendディレクトリにはGraphRAGの概念が技術的に組み込まれており、Apache AGEによる知識グラフ構築とCypherクエリ活用、LLMエージェントへのグラフ情報供給を通じて、マルチエージェントAIの回答精度とユーザ体験を大幅に向上させています。GraphRAGは本ソリューションアーキテクチャのキーストーンとなっており、今後の拡張においてもグラフデータを活用した高度な検索・推論が容易に行える土台を提供しています。各種リテールドメイン特有の関係性（製品－特徴－レビュー－ユーザ嗜好）をモデル化したこのグラフ活用アプローチは、従来のRAG手法では得られなかった洞察を引き出し、最終的なエンドユーザへの回答品質を押し上げています。

[前へ](06-WhyPostgreSQL.md) | [次へ](08-Wrapup.md)
